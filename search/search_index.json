{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Overview |       Features |       Setup |       Quick Start |       Examples |       Important Considerations |       Benchmarks |       Contributing |       See Also |       Citing |       Acknowledgments"},{"location":"#high-speed-buffers-in-jax","title":"\u26a1 High Speed Buffers In Jax \u26a1","text":""},{"location":"#overview","title":"Overview \ud83d\udd0d","text":"<p>Flashbax is a library designed to streamline the use of experience replay buffers within the context of reinforcement learning (RL). Tailored specifically for compatibility with the JAX paradigm, Flashbax allows these buffers to be easily utilised within fully compiled functions and training loops.</p> <p>Flashbax provides an implementation of various different types of buffers, such as Flat Buffer, Trajectory Buffer, and Prioritised variants of both. Whether for academic research, industrial applications, or personal projects, Flashbax offers a simple and flexible framework for RL experience replay handling.</p>"},{"location":"#features","title":"Features \ud83d\udee0\ufe0f","text":"<p>\ud83d\ude80 Efficient Buffer Variants: All Flashbax buffers are built as specialised variants of the trajectory buffer, optimising memory usage and functionality across various types of buffers.</p> <p>\ud83d\uddc4\ufe0f Flat Buffer: The Flat Buffer, akin to the transition buffer used in algorithms like DQN, is a core component. It employs a sequence of 2 (i.e. $s_t$, $s_{t+1}$), with a period of 1 for comprehensive transition pair consideration.</p> <p>\ud83e\uddfa Item Buffer: The Item Buffer is a simple buffer that stores individual items. It is useful for storing data that is independent of each other, such as (observation, action, reward, discount, next_observation) tuples, or entire episodes.</p> <p>\ud83d\udee4\ufe0f Trajectory Buffer: The Trajectory Buffer facilitates the sampling of multi-step trajectories, catering to algorithms utilising recurrent networks like R2D2 (Kapturowski et al., 2018).</p> <p>\ud83c\udfc5 Prioritised Buffers: Both Flat and Trajectory Buffers can be prioritised, enabling sampling based on user-defined priorities. The prioritisation mechanism aligns with the principles outlined in the PER paper (Schaul et al, 2016).</p> <p>\ud83d\udeb6 Trajectory/Flat Queue: A queue data structure is provided where one is expected to sample data in a FIFO order. The queue can be used for on-policy algorithms with specific use cases.</p>"},{"location":"#setup","title":"Setup \ud83c\udfac","text":"<p>To integrate Flashbax into your project, follow these steps:</p> <ol> <li> <p>Installation: Begin by installing Flashbax using <code>pip</code>: <pre><code>pip install flashbax\n</code></pre></p> </li> <li> <p>Selecting Buffers: Choose from a range of buffer options, including Flat Buffer, Trajectory Buffer, and Prioritised variants. <pre><code>import flashbax as fbx\n\nbuffer = fbx.make_trajectory_buffer(...)\n# OR\nbuffer = fbx.make_prioritised_trajectory_buffer(...)\n# OR\nbuffer = fbx.make_flat_buffer(...)\n# OR\nbuffer = fbx.make_prioritised_flat_buffer(...)\n# OR\nbuffer = fbx.make_item_buffer(...)\n# OR\nbuffer = fbx.make_trajectory_queue(...)\n\n# Initialise\nstate = buffer.init(example_timestep)\n# Add Data\nstate = buffer.add(state, example_data)\n# Sample Data\nbatch = buffer.sample(state, rng_key)\n</code></pre></p> </li> </ol>"},{"location":"#quickstart","title":"Quickstart \ud83c\udfc1","text":"<p>Below we provide a minimal code example for using the flat buffer. In this example, we show how each of the pure functions defining the flat buffer may be used. We note that each of these pure functions is compatible with <code>jax.pmap</code> and <code>jax.jit</code>, but for simplicity, these are not used in the below example.</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport flashbax as fbx\n\n# Instantiate the flat buffer NamedTuple using `make_flat_buffer` using a simple configuration.\n# The returned `buffer` is simply a container for the pure functions needed for using a flat buffer.\nbuffer = fbx.make_flat_buffer(max_length=32, min_length=2, sample_batch_size=1)\n\n# Initialise the buffer's state.\nfake_timestep = {\"obs\": jnp.array([0, 0]), \"reward\": jnp.array(0.0)}\nstate = buffer.init(fake_timestep)\n\n# Now we add data to the buffer.\nstate = buffer.add(state, {\"obs\": jnp.array([1, 2]), \"reward\": jnp.array(3.0)})\nprint(buffer.can_sample(state))  # False because min_length not reached yet.\n\nstate = buffer.add(state, {\"obs\": jnp.array([4, 5]), \"reward\": jnp.array(6.0)})\nprint(buffer.can_sample(state))  # Still False because we need 2 *transitions* (i.e. 3 timesteps).\n\nstate = buffer.add(state, {\"obs\": jnp.array([7, 8]), \"reward\": jnp.array(9.0)})\nprint(buffer.can_sample(state))  # True! We have 2 transitions (3 timesteps).\n\n# Get a transition from the buffer.\nrng_key = jax.random.PRNGKey(0)  # Source of randomness.\nbatch = buffer.sample(state, rng_key)  # Sample\n\n# We have a transition! Prints: obs = [[4 5]], obs' = [[7 8]]\nprint(\n    f\"obs = {batch.experience.first['obs']}, obs' = {batch.experience.second['obs']}\"\n)\n</code></pre>"},{"location":"#examples","title":"Examples \ud83e\uddd1\u200d\ud83d\udcbb","text":"<p>We provide the following Colab examples for a more advanced tutorial on how to use each of the flashbax buffers as well as usage examples:</p> Colab Notebook Description Flat Buffer Quickstart Trajectory Buffer Quickstart Prioritised Flat Buffer Quickstart Anakin DQN Anakin Prioritised DQN Anakin PPO DQN with Vectorised Gym Environments <ul> <li>\ud83d\udc7e Anakin - JAX based architecture for jit compiling the training of RL agents end-to-end.</li> <li>\ud83c\udfae DQN - implementation adapted from CleanRLs DQN JAX example.</li> <li>\ud83e\udd8e Jumanji - utilise Jumanji's JAX based environments like Snake for our fully jitted examples.</li> </ul>"},{"location":"#important-considerations","title":"Important Considerations \u26a0\ufe0f","text":"<p>When working with Flashbax buffers, it's crucial to be mindful of certain considerations to ensure the proper functionality of your RL agent.</p>"},{"location":"#sequential-data-addition","title":"Sequential Data Addition","text":"<p>Flashbax uses a trajectory buffer as the foundation for all buffer types. This means that data must be added sequentially. Specifically, for the flat buffer, each added timestep must be followed by its consecutive timestep. In most scenarios, this requirement is naturally satisfied and doesn't demand extensive consideration. However, it's essential to be aware of this constraint, especially when adding batches of data that are completely independent of each other. Failing to maintain the sequence relationship between timesteps can lead to algorithmic issues. The user is expected to handle the case of final to first timestep. This happens when going from episode <code>n</code> to episode <code>n+1</code> in the same batch. For example, we utilise auto reset wrappers to automatically reset the environment upon a terminal timestep. Additionally, we utilise discount values (1 for non-terminal state, 0 for terminal state) to mask the value function and discounting of rewards accordingly.</p>"},{"location":"#effective-buffer-size","title":"Effective Buffer Size","text":"<p>When adding batches of data, the buffer is created in a block-like structure. This means that the effective buffer size is dependent on the size of the batch dimension. The trajectory buffer allows a user to specify the add batch dimension and the max length of the time axis. This will create a block structure of (batch, time) allowing the maximum number of timesteps that can be in storage to be batch*time. For ease of use, we provide the max size argument that allows a user to set their total desired number of timesteps and we calculate the max length of the time axis dependent on the add batch dimension that is provided. Due to this, it is important to note that when using the max size argument, the max length of the time axis will be equal to max size // add batch size which will round down thereby reducing the effective buffer size. This means one might think they are increasing the buffer size by a certain amount but in actuality there is no increase. Therefore, to avoid this, we recommend one of two things: Use the max length time axis argument explicitly or increase the max size argument in multiples of the add batch size.</p>"},{"location":"#handling-episode-truncation","title":"Handling Episode Truncation","text":"<p>Another critical aspect is episode truncation. When truncating episodes and adding data to the buffer, it's vital to ensure that you set a done flag or a 'discount' value appropriately. Neglecting to do so can introduce challenges into your algorithm's implementation and behavior. As stated previously, it is expected that the algorithm handles these cases appropriately. It can be difficult handling truncation when using the flat buffer or trajectory buffer as the algorithm must handle the case of the final timestep in an episode being followed by the first timestep in the next episode. Sacrificing memory efficiency for ease of use, the item buffer can be used to store transitions or entire trajectories independently. This means that the algorithm does not need to handle the case of the final timestep in an episode being followed by the first timestep in the next episode as only the data that is explicitly inserted can be sampled.</p>"},{"location":"#independent-data-usage","title":"Independent Data Usage","text":"<p>For situations where you intend to utilise buffers with data that lack sequential information, you can leverage the item buffer which is a wrapped trajectory buffer with specific configurations. By setting a sequence dimension of 1 and a period of 1, each item will be treated as independent. However, when working with independent transition items like (observation, action, reward, discount, next_observation), be mindful that this approach will result in duplicate observations within the buffer, leading to unnecessary memory consumption. It is important to note that the implementation of the flat buffer will be slower than utilising the item buffer in this way due to the inherent speed issues that arise with data indexing on hardware accelerators; however, this trade-off is done to enhance memory efficiency. If speed is largely preferred over memory efficiency then use the trajectory buffer with sequence 1 and period 1 storing full transition data items.</p>"},{"location":"#in-place-updating-of-buffer-state","title":"In-place Updating of Buffer State","text":"<p>Since buffers are generally large and occupy a significant portion of device memory, it is beneficial to perform in-place updates. To do this, it is important to specify to the top-level compiled function that you would like to perform this in-place update operation. This is indicated as follows:</p> <pre><code>def train(train_state, buffer_state):\n    ...\n    return train_state, buffer_state\n\n# Initialise the buffer state\nbuffer_fn = fbx.make_trajectory_buffer(...)\nbuffer_state = buffer_fn.init(example_timestep)\n\n# Initialise some training state\ntrain_state = train_state.init(...)\n\n# Compile the training function and specify the donation of the buffer state argument\ntrain_state, buffer_state = jax.jit(train, donate_argnums=(1,))(\n    train_state, buffer_state\n)\n</code></pre> <p>It is important to include <code>donate_argnums</code> when calling <code>jax.jit</code> to enable JAX to perform an in-place update of the replay buffer state. Omitting <code>donate_argnums</code> would force JAX to create a copy of the state for any modifications to the replay buffer state, potentially negating all performance benefits. More information about buffer donation in JAX can be found in the documentation.</p> <p>In summary, understanding and addressing these considerations will help you navigate potential pitfalls and ensure the effectiveness of your reinforcement learning strategies while utilising Flashbax buffers.</p>"},{"location":"#benchmarks","title":"Benchmarks \ud83d\udcc8","text":"<p>Here we provide a series of initial benchmarks outlining the performance of the various Flashbax buffers compared against commonly used open-source buffers. In these benchmarks we (unless explicitly stated otherwise) use the following configuration:</p> Parameter Value Buffer Size 500_000 Sample Batch Size 256 Observation Size (32, 32, 3) Add Sequence Length 1 Add Sequence Batch Size 1 Sample Sequence Length 1 Sample Sequence Period 1 <p>The reason we use a sample sequence length and period of 1 is to directly compare to the other buffers, this means the speeds for the trajectory buffer are comparable to the speeds of the item buffer as the item buffer is simply a wrapped trajectory buffer with this configuration. This essentially means that the trajectory buffers are being used as memory inefficent transition buffers. It is important to note that the Flat Buffer implementations use a sample sequence length of 2. Additionally, one must bear in mind that not all other buffer implementations can efficiently make use of GPUs/TPUs thus they simply run on the CPU and perform device conversions. Lastly, we explicitly make use of python loops to fairly compare to the other buffers. Speeds can be largely improved using scan operations (depending on observation size).</p>"},{"location":"#cpu-speeds","title":"CPU Speeds","text":""},{"location":"#tpu-speeds","title":"TPU Speeds","text":""},{"location":"#gpu-speeds","title":"GPU Speeds","text":"<p>We notice strange behaviour with the GPU speeds when adding data. We believe this is due to the fact that certain JAX operations are not yet fully optimised for GPU usage as we see Dejax has the same performance issues. We expect these speeds to improve in the future.</p> <p> </p>"},{"location":"#cpu-gpu-tpu-adding-batches","title":"CPU, GPU, &amp; TPU Adding Batches","text":"<p>Previous benchmarks added only a single timestep at a time, we now evaluate adding batches of 128 timesteps at a time - a feature that most would use in high-throughput RL. We only compare to the buffers which have this capability.</p> <p> </p> <p> </p> <p>Ultimately, we see improved or comparable performance to benchmarked buffers whilst providing buffers that are fully JAX-compatible in addition to other features such as batched adding as well as being able to add sequences of varying length. We do note that due to JAX having different XLA backends for CPU, GPU, and TPU, the performance of the buffers can vary depending on the device and the specific operation being called.</p>"},{"location":"#contributing","title":"Contributing \ud83e\udd1d","text":"<p>Contributions are welcome! See our issue tracker for good first issues. Please read our contributing guidelines for details on how to submit pull requests, our Contributor License Agreement, and community guidelines.</p>"},{"location":"#see-also","title":"See Also \ud83d\udcda","text":"<p>Checkout some of the other buffer libraries from the community that we have highlighted in our benchmarks.</p> <ul> <li>\ud83d\udcc0 Dejax: the first library to provide a JAX-compatible replay buffers.</li> <li>\ud83c\udfb6 Reverb: efficient replay buffers used for both local and large-scale distributed RL.</li> <li>\ud83c\udf70 Dopamine: research framework for fast prototyping, providing several core replay buffers.</li> <li>\ud83e\udd16 StableBaselines3: suite of reliable RL baselines with its own, easy-to-use replay buffers.</li> </ul>"},{"location":"#citing-flashbax","title":"Citing Flashbax \u270f\ufe0f","text":"<p>If you use Flashbax in your work, please cite the library using:</p> <pre><code>@misc{flashbax,\n    title={Flashbax: Streamlining Experience Replay Buffers for Reinforcement Learning with JAX},\n    author={Edan Toledo and Laurence Midgley and Donal Byrne and Callum Rhys Tilbury and\n    Matthew Macfarlane and Cyprien Courtot and Alexandre Laterre},\n    year={2023},\n    url={https://github.com/instadeepai/flashbax/},\n}\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements \ud83d\ude4f","text":"<p>The development of this library was supported with Cloud TPUs from Google's TPU Research Cloud (TRC) \ud83c\udf24.</p>"},{"location":"api/flat_buffer/","title":"Flat Buffer","text":""},{"location":"api/flat_buffer/#flashbax.buffers.flat_buffer.make_flat_buffer","title":"<code>make_flat_buffer(max_length, min_length, sample_batch_size, add_sequences=False, add_batch_size=None)</code>","text":"<p>Makes a trajectory buffer act as a flat buffer.</p> <p>Parameters:</p> Name Type Description Default <code>max_length</code> <code>int</code> <p>The maximum length of the buffer.</p> required <code>min_length</code> <code>int</code> <p>The minimum length of the buffer.</p> required <code>sample_batch_size</code> <code>int</code> <p>The batch size of the samples.</p> required <code>add_sequences</code> <code>Optional[bool]</code> <p>Whether data is being added in sequences to the buffer. If False, single transitions are being added each time add is called. Defaults to False.</p> <code>False</code> <code>add_batch_size</code> <code>Optional[int]</code> <p>If adding data in batches, what is the batch size that is being added each time. If None, single transitions or single sequences are being added each time add is called. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TrajectoryBuffer</code> <p>The buffer.</p> Source code in <code>flashbax/buffers/flat_buffer.py</code> <pre><code>def make_flat_buffer(\n    max_length: int,\n    min_length: int,\n    sample_batch_size: int,\n    add_sequences: bool = False,\n    add_batch_size: Optional[int] = None,\n) -&gt; TrajectoryBuffer:\n\"\"\"Makes a trajectory buffer act as a flat buffer.\n\n    Args:\n        max_length (int): The maximum length of the buffer.\n        min_length (int): The minimum length of the buffer.\n        sample_batch_size (int): The batch size of the samples.\n        add_sequences (Optional[bool], optional): Whether data is being added in sequences\n            to the buffer. If False, single transitions are being added each time add\n            is called. Defaults to False.\n        add_batch_size (Optional[int], optional): If adding data in batches, what is the\n            batch size that is being added each time. If None, single transitions or single\n            sequences are being added each time add is called. Defaults to None.\n\n    Returns:\n        The buffer.\"\"\"\n\n    return create_flat_buffer(\n        max_length=max_length,\n        min_length=min_length,\n        sample_batch_size=sample_batch_size,\n        add_sequences=add_sequences,\n        add_batch_size=add_batch_size,\n    )\n</code></pre>"},{"location":"api/prioritised_flat_buffer/","title":"Prioritised Flat Buffer","text":""},{"location":"api/prioritised_flat_buffer/#flashbax.buffers.prioritised_flat_buffer.make_prioritised_flat_buffer","title":"<code>make_prioritised_flat_buffer(max_length, min_length, sample_batch_size, add_sequences=False, add_batch_size=None, priority_exponent=0.6, device='cpu')</code>","text":"<p>Makes a prioritised trajectory buffer act as a prioritised flat buffer.</p> <p>Parameters:</p> Name Type Description Default <code>max_length</code> <code>int</code> <p>The maximum length of the buffer.</p> required <code>min_length</code> <code>int</code> <p>The minimum length of the buffer.</p> required <code>sample_batch_size</code> <code>int</code> <p>The batch size of the samples.</p> required <code>add_sequences</code> <code>Optional[bool]</code> <p>Whether data is being added in sequences to the buffer. If False, single transitions are being added each time add is called. Defaults to False.</p> <code>False</code> <code>add_batch_size</code> <code>Optional[int]</code> <p>If adding data in batches, what is the batch size that is being added each time. If None, single transitions or single sequences are being added each time add is called. Defaults to None.</p> <code>None</code> <code>priority_exponent</code> <code>float</code> <p>The exponent to use when calculating priorities. Defaults to 0.6.</p> <code>0.6</code> <code>device</code> <code>str</code> <p>Depending on desired backend - more optimised functions are selected.</p> <code>'cpu'</code> <p>Returns:</p> Type Description <code>PrioritisedTrajectoryBuffer</code> <p>The buffer.</p> Source code in <code>flashbax/buffers/prioritised_flat_buffer.py</code> <pre><code>def make_prioritised_flat_buffer(\n    max_length: int,\n    min_length: int,\n    sample_batch_size: int,\n    add_sequences: bool = False,\n    add_batch_size: Optional[int] = None,\n    priority_exponent: float = 0.6,\n    device: str = \"cpu\",\n) -&gt; PrioritisedTrajectoryBuffer:\n\"\"\"Makes a prioritised trajectory buffer act as a prioritised flat buffer.\n\n    Args:\n        max_length (int): The maximum length of the buffer.\n        min_length (int): The minimum length of the buffer.\n        sample_batch_size (int): The batch size of the samples.\n        add_sequences (Optional[bool], optional): Whether data is being added in sequences\n            to the buffer. If False, single transitions are being added each time add\n            is called. Defaults to False.\n        add_batch_size (Optional[int], optional): If adding data in batches, what is the\n            batch size that is being added each time. If None, single transitions or single\n            sequences are being added each time add is called. Defaults to None.\n        priority_exponent (float, optional): The exponent to use when calculating priorities.\n            Defaults to 0.6.\n        device (str): Depending on desired backend - more optimised functions are selected.\n\n    Returns:\n        The buffer.\"\"\"\n\n    if add_batch_size is None:\n        # add_batch_size being None implies that we are adding single transitions\n        add_batch_size = 1\n        add_batches = False\n    else:\n        add_batches = True\n\n    validate_priority_exponent(priority_exponent)\n    validate_flat_buffer_args(\n        max_length=max_length,\n        min_length=min_length,\n        sample_batch_size=sample_batch_size,\n        add_batch_size=add_batch_size,\n    )\n    if not validate_device(device):\n        device = \"cpu\"\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\",\n            message=\"Setting max_size dynamically sets the `max_length_time_axis` to \"\n            f\"be `max_size`//`add_batch_size = {max_length // add_batch_size}`.\"\n            \"This allows one to control exactly how many transitions are stored in the buffer.\"\n            \"Note that this overrides the `max_length_time_axis` argument.\",\n        )\n\n        buffer = make_prioritised_trajectory_buffer(\n            max_length_time_axis=None,  # Unused because max_size is specified\n            min_length_time_axis=min_length // add_batch_size + 1,\n            add_batch_size=add_batch_size,\n            sample_batch_size=sample_batch_size,\n            sample_sequence_length=2,\n            period=1,\n            max_size=max_length,\n            priority_exponent=priority_exponent,\n            device=device,\n        )\n\n    add_fn = buffer.add\n\n    if not add_batches:\n        add_fn = add_dim_to_args(\n            add_fn, axis=0, starting_arg_index=1, ending_arg_index=2\n        )\n\n    if not add_sequences:\n        axis = 1 - int(not add_batches)  # 1 if add_batches else 0\n        add_fn = add_dim_to_args(\n            add_fn, axis=axis, starting_arg_index=1, ending_arg_index=2\n        )\n\n    def sample_fn(\n        state: PrioritisedTrajectoryBufferState, rng_key: PRNGKey\n    ) -&gt; TransitionSample:\n\"\"\"Samples a batch of transitions from the buffer.\"\"\"\n        sampled_batch = buffer.sample(state, rng_key)\n        first = jax.tree_util.tree_map(lambda x: x[:, 0], sampled_batch.experience)\n        second = jax.tree_util.tree_map(lambda x: x[:, 1], sampled_batch.experience)\n        return PrioritisedTransitionSample(\n            experience=ExperiencePair(first=first, second=second),\n            indices=sampled_batch.indices,\n            priorities=sampled_batch.priorities,\n        )\n\n    return buffer.replace(add=add_fn, sample=sample_fn)  # type: ignore\n</code></pre>"},{"location":"api/prioritised_trajectory_buffer/","title":"Prioritised Trajectory Buffer","text":"<p>             Bases: <code>TrajectoryBuffer[Experience, BufferState, BufferSample]</code></p> <p>Pure functions defining the prioritised trajectory buffer. This buffer behaves like a trajectory buffer, however it also stores the priorities of the data subsequences in a sum tree.</p> <p>Attributes:</p> Name Type Description <code>init</code> <p>A pure function which may be used to initialise the buffer state using a single timestep (e.g. (s,a,r)).</p> <code>add</code> <p>A pure function for adding a new batch of experience to the buffer state.</p> <code>sample</code> <p>A pure function for sampling a batch of data from the replay buffer, with a leading axis of size (<code>sample_batch_size</code>, <code>sample_sequence_length</code>). Note <code>sample_batch_size</code> and <code>sample_sequence_length</code> may be different to the batch size and sequence length of data added to the state using the <code>add</code> function.</p> <code>can_sample</code> <p>Whether the buffer can be sampled from, which is determined by if the number of trajectories added to the buffer state is greater than or equal to the <code>min_length</code>.</p> <code>set_priorities</code> <code>Callable[[BufferState, Indices, Priorities], BufferState]</code> <p>A pure function for setting the priorities of the data subsequences in the buffer.</p> <p>See <code>make_prioritised_trajectory_buffer</code> for how this container is instantiated.</p>"},{"location":"api/trajectory_buffer/","title":"Trajectory Buffer","text":"<p>             Bases: <code>Generic[Experience, BufferState, BufferSample]</code></p> <p>Pure functions defining the trajectory buffer. This buffer assumes batches added to the buffer are a pytree with a shape prefix of (batch_size, trajectory_length). Consecutive batches are then concatenated along the second axis (i.e. the time axis). During sampling this allows for trajectories to be sampled - by slicing consecutive sequences along the time axis.</p> <p>Attributes:</p> Name Type Description <code>init</code> <code>Callable[[Experience], BufferState]</code> <p>A pure function which may be used to initialise the buffer state using a single timestep (e.g. (s,a,r)).</p> <code>add</code> <code>Callable[[BufferState, Experience], BufferState]</code> <p>A pure function for adding a new batch of experience to the buffer state.</p> <code>sample</code> <code>Callable[[BufferState, PRNGKey], BufferSample]</code> <p>A pure function for sampling a batch of data from the replay buffer, with a leading axis of size (<code>sample_batch_size</code>, <code>sample_sequence_length</code>). Note <code>sample_batch_size</code> and <code>sample_sequence_length</code> may be different to the batch size and sequence length of data added to the state using the <code>add</code> function.</p> <code>can_sample</code> <code>Callable[[BufferState], Array]</code> <p>Whether the buffer can be sampled from, which is determined by if the number of trajectories added to the buffer state is greater than or equal to the <code>min_length</code>.</p> <p>See <code>make_trajectory_buffer</code> for how this container is instantiated.</p>"},{"location":"api/trajectory_queue/","title":"Trajectory Queue","text":"<p>             Bases: <code>Generic[Experience]</code></p> <p>Pure functions defining the trajectory queue. This queue assumes batches added to the queue are a pytree with a shape prefix of (batch_size, trajectory_length). Consecutive batches are then concatenated along the second axis (i.e. the time axis). During sampling this allows for trajectories to be sampled - by slicing consecutive sequences along the time axis.</p> <p>Attributes:</p> Name Type Description <code>init</code> <code>Callable[[Experience], TrajectoryQueueState[Experience]]</code> <p>A pure function which may be used to initialise the queue state using a single timestep (e.g. (s,a,r)).</p> <code>add</code> <code>Callable[[TrajectoryQueueState[Experience], Experience], TrajectoryQueueState[Experience]]</code> <p>A pure function for adding a new batch of experience to the queue state.</p> <code>sample</code> <code>Callable[[TrajectoryQueueState[Experience]], Tuple[TrajectoryQueueState, TrajectoryQueueSample[Experience]]]</code> <p>A pure function for sampling a batch of data from the replay queue, with a leading axis of size (<code>sample_batch_size</code>, <code>sample_sequence_length</code>). Note <code>sample_batch_size</code> is the same as the batch size when adding data to the queue. However, <code>sample_sequence_length</code> may be different to the sequence length of data added to the state using the <code>add</code> function.</p> <code>can_sample</code> <code>Callable[[TrajectoryQueueState[Experience]], Array]</code> <p>Whether the queue can be sampled from.</p> <code>can_add</code> <code>Callable[[TrajectoryQueueState[Experience]], Array]</code> <p>Whether the queue can be added to.</p> <p>See <code>make_trajectory_queue</code> for how this container is instantiated.</p>"}]}